<!--
Copyright (c) 2016 Andre Engelbrecht

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">


<script>
    /**
     * A base behaviour that will allow for changing page context.
     */
    var XHRContextBehavior = {
        properties: {
            /**
             * What will the new page title be when applied
             */
            pageTitle: String,

            /**
             * The selector for the xhr element that should manage state
             * if required.
             */
            xhrSelector: {
                type: String,
                value: "#xhrContent"
            }
        },

        attached: function() {
            document.querySelector(this.xhrSelector).setContext(this);
        }
    };
</script>


<!--
`ostinato-xhr`
Makes an ajax request to a resource, and inserts the html response into the
target dom node(s).

@demo demo/index.html 
-->
<dom-module id="ostinato-xhr">
    <template>
        <iron-ajax
            id="xhr"
            method="[[method]]"
            handle-as="text"
            headers='{"X-Requested-With": "XMLHttpRequest"}'
            content-type="[[contentType]]"
            on-response="_handleResponse"
            on-error="_handleError"></iron-ajax>
    </template>
    <script>
        Polymer({
            is: 'ostinato-xhr',

            properties: {
                /**
                 * A comma separated list of target element selectors which
                 * should receive the new content.
                 * If these nodes exist in the response content, then it will
                 * be extracted directly from the response.
                 */
                targetSelectors: String,

                /**
                 * The http method to use for the request
                 */
                method: {
                    type: String,
                    value: 'get'
                },

                /**
                 * The contenttype to use for the request
                 */
                contentType: {
                    type: String,
                    value: null
                },

                /**
                 * Set to true if you don't want to run any imports that the
                 * new content might have in <head>
                 */
                skipImports: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Whether or not to update the browser history when this
                 * component is used.
                 */
                updateHistory: {
                    type: Boolean,
                    value: false
                }
            },

            attached: function() {
                if (this.updateHistory) {
                    window.addEventListener('popstate', function(ev) {
                        if (ev.state) {
                            /*
                               Only generate the request if the urls actually
                               changed.

                               Compare the urls without any hash values.
                               This is because we don't want a hash to generate
                               a request. Hash changes are only for on page
                               anchors.
                            */
                            // FIXME: The regex below extracts the base url, but
                            // it would be nice if we could use the URL api.
                            // Unfortunately this is not supported by IE11.
                            // We will replace this in future, but only when IE11
                            // is sufficiently small in use.
                            var re = new RegExp("#([^\\s]*)");
                            var stateUrl = ev.state.url.replace(re, '');
                            var xhrUrl = this.$.xhr.url ? this.$.xhr.url.replace(re, '') : "";

                            if (xhrUrl != stateUrl) {
                                this.generateRequest(ev.state.url);
                            }
                        }
                    }.bind(this));
                }
            },

            /**
             * Make a request to the url, optionally passing data
             */
            generateRequest: function(url, data) {
                this.debounce(url, function() {
                    if (data) this.$.xhr.body = data;
                    this.$.xhr.url = url;
                    this.fire('request-started');
                    this.$.xhr.generateRequest();
                });
            },

            /**
             * The response is where the majority of the heavy lifting happens.
             *
             * First it will parse the response string into a new html document.
             * This document can then be queried like any other html doc.
             *
             * We then have to find any imports in this document, and make sure
             * that we manually import those, before doing anything else.
             * Since each import happens asyncronously, we will wait for all
             * imports to finish, before we proceed to the next step.
             *
             * Once all the imports are finished, we can then insert content
             * into their respecive containers.
             *
             * WARNING: Regarding `<style>` tags inside imports.
             * Style tags in the top level of the imported document will be
             * applied for every request, but won't be re-applied when you come
             * back to a page that have already been imported. Because of this
             * you'll tart seeing style conflicts, as you navigate to one page,
             * and then back to a previous page.
             * For this reason it's propably better to wrap your custom styles
             * in a webcomponent's shadow dom, and then use that component to
             * style your content.
             */
            _handleResponse: function() {
                this.fire('request-completed');

                var doc = new DOMParser().parseFromString(this.$.xhr.lastResponse, "text/html");
                var targetSelectorList = this.targetSelectors.split(',');

                if (this.skipImports) {
                    this._insertContent(doc, targetSelectorList);
                    this.fire('content-updated');
                } else {
                    // Since we might have new imports for the page being loaded
                    // we need to ensure that we import them before putting any
                    // content into the dom.
                    var importList = doc.querySelectorAll('link[rel="import"]');
                    if (importList) {
                        this.importsFinished = false;

                        // Import each document
                        importList.forEach(function(link, index) {
                            this.importHref(link.getAttribute('href'), function(e) {
                                // e.target.import is the import document.
                                // No need to do anything here for now ...
                                if (index == importList.length - 1) {
                                    this.importsFinished = true;
                                }
                            }, function(e) {
                                // loading error
                                if (index == importList.length - 1) {
                                    this.importsFinished = true;
                                }
                                throw 'Error: Could not import document, "' + link.getAttribute('href') + '"';
                            });
                        }.bind(this));

                        // Load the content for each of the targets
                        // We need to wait for every import to finish
                        var importCheck = window.setInterval(function() {
                            if (this.importsFinished) {
                                this.fire('imports-finished', {importList: importList});
                                this._insertContent(doc, targetSelectorList);
                                window.clearInterval(importCheck);
                            }
                        }.bind(this), 50);
                    }

                    // Compensate for the interval import check above.
                    this.async(function() {
                        this.fire('content-updated');
                    }, 50);
                }
            },

            _insertContent: function(doc, targetSelectorList) {
                targetSelectorList.forEach(function(targetSelector) {
                    var target = document.querySelector(targetSelector);
                    var content = doc.querySelector(targetSelector);

                    if (content) {
                        target.innerHTML = content.innerHTML;
                    }
                });
            },

            setContext: function(context) {
                if (this.updateHistory && this.$.xhr.url) {
                    var currentState = window.history.state;
                    var state = {
                        title: context.pageTitle,
                        url: this.$.xhr.url
                    };

                    // Only push the state if it actually changed
                    if ((!currentState) || (state.url != window.history.state.url)) {
                        window.history.pushState(state, context.pageTitle, this.$.xhr.url);
                    }

                    // Due to a bug in many browsers, history api doesn't
                    // always update the title.
                    // do so manually here till this is fixed in browsers.
                    document.title = context.pageTitle;

                    this.fire('history-updated', {
                        title: state.title,
                        url: state.url
                    });
                }
                this.fire('context-attached', {context: context});
            },

            _handleError: function(ev) {
                this.fire('error', ev.detail);
            }
        });
    </script>
</dom-module>


<!--
`ostinato-xhr-triggers`
Use this element to specify which elements should behave as ostinato-xhr
triggers. This will only handle triggers that is wrapped inside this element.
-->
<script>
    Polymer({
        is: 'ostinato-xhr-triggers',

        properties: {
            /**
             * The query selector for the `ostinato-xhr` element to use when
             * making the request.
             */
            xhrSelector: {
                type: String,
                value: "#xhrContent"
            },

            triggerSelector: {
                type: String,
                value: "[xhr-link]"
            }
        },

        ready: function() {
            var triggerList = document.querySelectorAll(this.triggerSelector);
            if (triggerList) {
                triggerList.forEach(function(trigger) {
                    trigger.addEventListener('click', function(ev) {
                        ev.preventDefault();
                        this.triggerRequest(ev.currentTarget.href);
                    }.bind(this));
                }.bind(this));
            }
        },

        /**
         * Get the `ostinato-xhr` element and make the request.
         */
        triggerRequest: function(href) {
            var loader = document.querySelector(this.xhrSelector);
            loader.generateRequest(href);
        }
    });
</script>
